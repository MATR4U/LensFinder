<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Ultimate Camera System Builder</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Plotly.js for charting -->
    <script src="https://cdn.plot.ly/plotly-2.33.0.min.js"></script>
    
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
     <link rel="stylesheet" href="styles.css">
    
    <!-- Lucide Icons (removed React version; not used) -->
</head>
<body class="antialiased">

    <div class="flex min-h-screen">
        <!-- Sidebar -->
        <aside id="sidebar" class="sidebar fixed lg:relative inset-y-0 left-0 z-30 w-80 bg-gray-900 border-r border-gray-800 p-6 space-y-6 transform -translate-x-full lg:translate-x-0">
            <div class="flex items-center justify-between">
                 <h1 class="text-xl font-bold text-white">üì∑ System Builder</h1>
                 <button id="sidebar-close" class="lg:hidden p-2 rounded-md text-gray-400 hover:bg-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                 </button>
            </div>
            
            <div class="flex items-center justify-center space-x-4 p-2 bg-gray-800 rounded-lg">
                <span id="newbie-label" class="text-sm font-medium text-gray-400">Beginner</span>
                <label for="ui-mode-toggle" class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="ui-mode-toggle" class="sr-only peer" checked>
                    <div class="w-11 h-6 bg-gray-700 rounded-full peer peer-focus:ring-4 peer-focus:ring-blue-800 toggle-bg"></div>
                </label>
                <span id="pro-label" class="text-sm font-medium text-white">Professional</span>
            </div>

            <div id="sidebar-content" class="space-y-6 overflow-y-auto h-[calc(100vh-150px)] pr-2">
                <div class="space-y-4">
                    <h2 class="text-lg font-semibold text-gray-200 border-b border-gray-700 pb-2">System & Filters</h2>
                    <div>
                        <label for="camera_body" class="block text-sm font-medium text-gray-400 mb-1">Camera Body</label>
                        <select id="camera_body" class="w-full bg-gray-800 border border-gray-700 text-white rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"></select>
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="brand" class="block text-sm font-medium text-gray-400 mb-1">Lens Brand</label>
                            <select id="brand" class="w-full bg-gray-800 border border-gray-700 text-white rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"></select>
                        </div>
                        <div>
                            <label for="lens_type" class="block text-sm font-medium text-gray-400 mb-1">Lens Type</label>
                            <select id="lens_type" class="w-full bg-gray-800 border border-gray-700 text-white rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"></select>
                        </div>
                    </div>
                    <div>
                        <label for="price" class="block text-sm font-medium text-gray-400 mb-1">Price (CHF)</label>
                        <input type="range" id="price" class="w-full">
                        <div class="flex justify-between text-xs text-gray-500 mt-1">
                            <span id="price-min-label">0</span>
                            <span id="price-max-label">5000</span>
                        </div>
                    </div>

                    <div>
                        <label for="weight" class="block text-sm font-medium text-gray-400 mb-1">Weight (g)</label>
                        <input type="range" id="weight" class="w-full">
                         <div class="flex justify-between text-xs text-gray-500 mt-1">
                            <span id="weight-min-label">0</span>
                            <span id="weight-max-label">2000</span>
                        </div>
                    </div>
                    
                    <div class="flex items-center space-x-6 pt-2">
                        <label class="flex items-center space-x-2 text-sm text-gray-300">
                            <input type="checkbox" id="weather_sealed" class="h-4 w-4 rounded bg-gray-700 border-gray-600 text-blue-600 focus:ring-blue-500">
                            <span>Weather Sealed</span>
                        </label>
                         <label class="flex items-center space-x-2 text-sm text-gray-300">
                            <input type="checkbox" id="is_macro" class="h-4 w-4 rounded bg-gray-700 border-gray-600 text-blue-600 focus:ring-blue-500">
                            <span>Macro</span>
                        </label>
                    </div>
                </div>

                <div id="pro-sections" class="space-y-6">
                    <div id="simulation-section" class="space-y-4">
                        <h2 class="text-lg font-semibold text-gray-200 border-b border-gray-700 pb-2">Simulation</h2>
                        <div>
                            <label for="focal_choice" class="block text-sm font-medium text-gray-400 mb-1">Focal Length (mm)</label>
                            <input type="number" id="focal_choice" value="50" min="5" max="800" step="1" class="w-full bg-gray-800 border border-gray-700 text-white rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        </div>
                        <div>
                            <label for="subject_distance" class="block text-sm font-medium text-gray-400 mb-1">Subject Distance (m)</label>
                            <input type="number" id="subject_distance" value="3.0" min="0.2" max="100" step="0.1" class="w-full bg-gray-800 border border-gray-700 text-white rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        </div>
                    </div>

                    <div class="space-y-4">
                        <h2 class="text-lg font-semibold text-gray-200 border-b border-gray-700 pb-2">Goal & Weights</h2>
                        <div>
                            <label for="goal_preset" class="block text-sm font-medium text-gray-400 mb-1">Preset</label>
                            <select id="goal_preset" class="w-full bg-gray-800 border border-gray-700 text-white rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"></select>
                        </div>
                        <details id="custom-weights-details" class="text-sm">
                            <summary class="cursor-pointer text-gray-400 hover:text-white">Custom Weights</summary>
                            <div id="custom-weights" class="mt-4 space-y-3 pl-2 border-l-2 border-gray-700"></div>
                        </details>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Main content -->
        <main class="flex-1 p-6 lg:p-8 bg-gray-900/50">
             <button id="sidebar-open" class="lg:hidden p-2 rounded-md bg-gray-800 text-gray-400 hover:bg-gray-700 mb-4">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
            </button>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                <div id="system-card" class="md:col-span-2 bg-gray-800/50 p-6 rounded-xl border border-gray-700 flex items-center space-x-6">
                    <div id="camera-icon" class="w-24 h-24 text-blue-400 flex-shrink-0"></div>
                    <div>
                        <h2 id="system-camera-name" class="text-2xl font-bold text-white"></h2>
                        <p id="system-lens-name" class="text-lg text-gray-300">No lens selected</p>
                    </div>
                </div>
                <div class="bg-gray-800/50 p-6 rounded-xl border border-gray-700 space-y-2">
                     <h3 class="text-sm font-medium text-gray-400">System Weight</h3>
                     <p id="system-weight" class="text-3xl font-bold text-white">0 g</p>
                     <h3 class="text-sm font-medium text-gray-400 pt-2">System Cost</h3>
                     <p id="system-cost" class="text-3xl font-bold text-white">CHF 0</p>
                </div>
            </div>

            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-white">Compatible Lenses</h2>
                <button id="download-csv" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md transition-colors">Download Results (CSV)</button>
            </div>

            <div id="results-container" class="bg-gray-800/50 rounded-xl border border-gray-700 overflow-hidden">
                <div class="overflow-x-auto">
                    <table class="min-w-full">
                        <thead class="bg-gray-800 sticky top-0">
                            <tr id="results-header"></tr>
                        </thead>
                        <tbody id="results-body" class="divide-y divide-gray-700"></tbody>
                    </table>
                </div>
            </div>
            <div id="no-results" class="hidden text-center py-16 bg-gray-800/50 rounded-xl border border-gray-700">
                <p class="text-gray-400">No lenses match the current filters.</p>
            </div>

            <!-- Charts -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
                <div id="chart-fov" class="bg-gray-800/50 p-4 rounded-xl border border-gray-700"></div>
                <div id="chart-score" class="bg-gray-800/50 p-4 rounded-xl border border-gray-700"></div>
            </div>
        </main>
    </div>
    
    <script>
        // --- DATA MODULE ---
        // Data loaded from external JSON files
        
        // --- OPTICS & RECOMMENDER MODULES (unchanged) ---
        const optics = {
            fovDeg(sensor, focal_mm) {
                const h = 2 * (180 / Math.PI) * Math.atan(sensor.width_mm / (2 * focal_mm));
                const v = 2 * (180 / Math.PI) * Math.atan(sensor.height_mm / (2 * focal_mm));
                const d = 2 * (180 / Math.PI) * Math.atan(Math.hypot(sensor.width_mm, sensor.height_mm) / (2 * focal_mm));
                return { h, v, d };
            },
            hyperfocalMm(focal_mm, f_number, coc_mm) {
                return (focal_mm * focal_mm) / (f_number * coc_mm) + focal_mm;
            },
            depthOfFieldMm(focal_mm, f_number, coc_mm, subject_distance_mm) {
                const H = this.hyperfocalMm(focal_mm, f_number, coc_mm);
                const s = subject_distance_mm;
                const f = focal_mm;
                if (s <= f) return { near: 0, far: 0, total: 0 };
                const near = (H * s) / (H + (s - f));
                const far = (H > (s - f)) ? (H * s) / (H - (s - f)) : Infinity;
                const total = (far !== Infinity) ? far - near : Infinity;
                return { near, far, total };
            },
            equivFocalFf(focal_mm, sensor) { return focal_mm * sensor.crop; },
            lightGatheringScore(focal_mm, f_number) { if (f_number <= 0) return 0; const diameter = focal_mm / f_number; return Math.PI * Math.pow(diameter / 2, 2); },
            stabilizationBonus(stops) { return 1.0 + (Math.pow(2, stops) - 1.0) * 0.2; }
        };
        const recommender = {
            DEFAULT_STOPS_IF_OIS: 3.5,
            PRESETS: {
                "Balanced":    { low_light: 0.5, background_blur: 0.5, reach: 0.5, wide: 0.5, portability: 0.5, value: 0.5, distortion_control: 0.3, video_excellence: 0.3 },
                "Portrait":    { low_light: 0.8, background_blur: 1.0, reach: 0.2, wide: 0.0, portability: 0.2, value: 0.2, distortion_control: 0.4, video_excellence: 0.1 },
                "Landscape":   { low_light: 0.2, background_blur: 0.1, reach: 0.0, wide: 1.0, portability: 0.3, value: 0.3, distortion_control: 0.8, video_excellence: 0.1 },
                "Architecture":{ low_light: 0.2, background_blur: 0.0, reach: 0.0, wide: 1.0, portability: 0.2, value: 0.2, distortion_control: 1.0, video_excellence: 0.1 },
                "Sports":      { low_light: 0.5, background_blur: 0.5, reach: 1.0, wide: 0.0, portability: 0.1, value: 0.2, distortion_control: 0.2, video_excellence: 0.4 },
                "Travel":      { low_light: 0.4, background_blur: 0.3, reach: 0.4, wide: 0.4, portability: 1.0, value: 0.5, distortion_control: 0.5, video_excellence: 0.3 },
                "Street":      { low_light: 0.7, background_blur: 0.5, reach: 0.1, wide: 0.5, portability: 1.0, value: 0.4, distortion_control: 0.6, video_excellence: 0.2 },
                "Video/Vlog":  { low_light: 0.4, background_blur: 0.3, reach: 0.1, wide: 1.0, portability: 0.8, value: 0.4, distortion_control: 0.5, video_excellence: 1.0 },
                "Astrophotography": { low_light: 1.0, background_blur: 0.1, reach: 0.0, wide: 1.0, portability: 0.1, value: 0.3, distortion_control: 0.7, video_excellence: 0.0 },
                "Low Light":   { low_light: 1.0, background_blur: 0.7, reach: 0.1, wide: 0.1, portability: 0.2, value: 0.2, distortion_control: 0.3, video_excellence: 0.1 },
            },
            isZoom(lens) { return lens.focal_min_mm !== lens.focal_max_mm; },
            maxApertureAt(lens, focal_mm) { if (!this.isZoom(lens) || Math.abs(lens.aperture_min - lens.aperture_max) < 1e-6) { return lens.aperture_min; } const ratio = (focal_mm - lens.focal_min_mm) / (lens.focal_max_mm - lens.focal_min_mm); const clampedRatio = Math.min(Math.max(ratio, 0.0), 1.0); return lens.aperture_min + clampedRatio * (lens.aperture_max - lens.aperture_min); },
            scoreLens(lens, camera, goal_weights, focal_choice_mm) {
                const maxAperture = this.maxApertureAt(lens, focal_choice_mm);
                let low_light = optics.lightGatheringScore(focal_choice_mm, maxAperture);
                if (lens.ois || camera.ibis) { low_light *= optics.stabilizationBonus(this.DEFAULT_STOPS_IF_OIS); }
                const background_blur = optics.lightGatheringScore(focal_choice_mm, maxAperture);
                const equiv_wide = optics.equivFocalFf(lens.focal_min_mm, camera.sensor);
                const equiv_tele = optics.equivFocalFf(lens.focal_max_mm, camera.sensor);
                const reach = Math.max(0.0, equiv_tele - 100);
                const wide = Math.max(0.0, 35 - equiv_wide);
                const portability = 1000 / (lens.weight_g + 100);
                const value = 5000 / (lens.price_chf + 200);
                const distortion_control = 10 / (Math.abs(lens.distortion_pct) + 1);
                const video_excellence = lens.focus_breathing_score;
                const raw = { low_light, background_blur, reach, wide, portability, value, distortion_control, video_excellence };
                let total = 0;
                for (const key in raw) { total += (raw[key] || 0) * (goal_weights[key] || 0.0); }
                raw.total = total;
                return raw;
            }
        };

        // --- MAIN APP LOGIC ---
        document.addEventListener('DOMContentLoaded', () => {
            const state = {
                cameras: [],
                lenses: [],
                results: [],
                selectedLens: null,
                filters: {
                    camera: null,
                    brand: 'Any',
                    lens_type: 'Any',
                    weather_sealed: false,
                    is_macro: false,
                    price: { min: 0, max: 5000 },
                    weight: { min: 0, max: 2000 },
                    focal_choice: 50,
                    subject_distance: 3.0,
                    goal_weights: recommender.PRESETS['Balanced'],
                    isProMode: true
                }
            };

            const elements = {
                // All element selectors...
                uiModeToggle: document.getElementById('ui-mode-toggle'),
                newbieLabel: document.getElementById('newbie-label'),
                proLabel: document.getElementById('pro-label'),
                proSections: document.getElementById('pro-sections'),
                camera_body: document.getElementById('camera_body'),
                brand: document.getElementById('brand'),
                lens_type: document.getElementById('lens_type'),
                price: document.getElementById('price'),
                priceMinLabel: document.getElementById('price-min-label'),
                priceMaxLabel: document.getElementById('price-max-label'),
                weight: document.getElementById('weight'),
                weightMinLabel: document.getElementById('weight-min-label'),
                weightMaxLabel: document.getElementById('weight-max-label'),
                weather_sealed: document.getElementById('weather_sealed'),
                is_macro: document.getElementById('is_macro'),
                focalChoice: document.getElementById('focal_choice'),
                subjectDistance: document.getElementById('subject_distance'),
                goalPreset: document.getElementById('goal_preset'),
                customWeights: document.getElementById('custom-weights'),
                customWeightsDetails: document.getElementById('custom-weights-details'),
                resultsHeader: document.getElementById('results-header'),
                resultsBody: document.getElementById('results-body'),
                resultsContainer: document.getElementById('results-container'),
                noResults: document.getElementById('no-results'),
                downloadCsv: document.getElementById('download-csv'),
                systemCameraName: document.getElementById('system-camera-name'),
                systemLensName: document.getElementById('system-lens-name'),
                systemWeight: document.getElementById('system-weight'),
                systemCost: document.getElementById('system-cost'),
                cameraIcon: document.getElementById('camera-icon'),
                sidebar: document.getElementById('sidebar'),
                sidebarOpen: document.getElementById('sidebar-open'),
                sidebarClose: document.getElementById('sidebar-close'),
            };

            function init() {
                // Initialization logic...
                populateSelect(elements.camera_body, state.cameras.map(c => c.name), state.filters.camera.name);
                populateSelect(elements.lens_type, ['Any', 'Prime', 'Zoom']);
                populateSelect(elements.goalPreset, Object.keys(recommender.PRESETS), 'Balanced');
                setupRangeSlider(elements.price, state.lenses.map(l=>l.price_chf), elements.priceMinLabel, elements.priceMaxLabel, 'price');
                setupRangeSlider(elements.weight, state.lenses.map(l=>l.weight_g), elements.weightMinLabel, elements.weightMaxLabel, 'weight');
                createWeightSliders();
                addEventListeners();
                updateUIMode();
                update();
            }

            async function loadDataThenInit() {
                try {
                    const [camerasRes, lensesRes] = await Promise.all([
                        fetch('data/cameras.json'),
                        fetch('data/lenses.json')
                    ]);
                    const [cameras, lenses] = await Promise.all([
                        camerasRes.json(),
                        lensesRes.json()
                    ]);
                    state.cameras = cameras;
                    state.lenses = lenses;
                    state.filters.camera = state.cameras.find(c => c.name === 'Sony a7 IV') || state.cameras[0] || null;
                    if (!state.filters.camera) {
                        console.error('No cameras loaded');
                        return;
                    }
                    init();
                } catch (err) {
                    console.error('Initialization error', err);
                }
            }

            function populateSelect(el, options, selectedValue) {
                const hasAny = options.includes('Any');
                let sortedOptions = hasAny ? ['Any', ...options.filter(o => o !== 'Any').sort()] : [...options].sort();
                
                el.innerHTML = sortedOptions.map(opt => `<option value="${opt}" ${opt === selectedValue ? 'selected' : ''}>${opt}</option>`).join('');
            }
            
            function setupRangeSlider(el, data, minLabel, maxLabel, filterKey) {
                const min = 0;
                const max = Math.ceil(Math.max(...data, 1000) / 100) * 100;
                el.min = min;
                el.max = max;
                el.value = max;
                state.filters[filterKey] = { min: min, max: max };
                
                let minSlider = el.parentNode.querySelector('.min-slider');
                if (!minSlider) {
                    minSlider = document.createElement('input');
                    minSlider.type = 'range';
                    minSlider.className = el.className + ' min-slider';
                    // Insert before the labels container (the next element sibling),
                    // falling back to append if not found
                    const refNode = el.nextElementSibling;
                    if (refNode) {
                        el.parentNode.insertBefore(minSlider, refNode);
                    } else {
                        el.parentNode.appendChild(minSlider);
                    }
                }
                minSlider.min = min;
                minSlider.max = max;
                minSlider.value = min;

                const updateLabels = () => {
                     minLabel.textContent = minSlider.value;
                     maxLabel.textContent = el.value;
                }

                minSlider.oninput = () => {
                    if (parseInt(minSlider.value) > parseInt(el.value)) minSlider.value = el.value;
                    state.filters[filterKey].min = parseInt(minSlider.value);
                    updateLabels();
                    update();
                };

                el.oninput = () => {
                    if (parseInt(el.value) < parseInt(minSlider.value)) el.value = minSlider.value;
                    state.filters[filterKey].max = parseInt(el.value);
                    updateLabels();
                    update();
                };
                updateLabels();
            }

            function createWeightSliders() {
                const weights = state.filters.goal_weights;
                elements.customWeights.innerHTML = '';
                for (const key in weights) {
                    const container = document.createElement('div');
                    const label = document.createElement('label');
                    label.className = "block text-sm font-medium text-gray-400 mb-1 capitalize";
                    label.textContent = key.replace(/_/g, ' ');
                    const slider = document.createElement('input');
                    slider.type = 'range';
                    slider.min = 0;
                    slider.max = 1;
                    slider.step = 0.05;
                    slider.value = weights[key];
                    slider.dataset.key = key;
                    slider.className = "w-full";
                    container.appendChild(label);
                    container.appendChild(slider);
                    elements.customWeights.appendChild(container);
                }
            }
            
            function handleUIModeChange(e) {
                state.filters.isProMode = e.target.checked;
                updateUIMode();
            }

            function addEventListeners() {
                // Event listeners...
                elements.uiModeToggle.addEventListener('change', handleUIModeChange);
                elements.camera_body.addEventListener('change', handleFilterChange);
                elements.brand.addEventListener('change', handleFilterChange);
                elements.lens_type.addEventListener('change', handleFilterChange);
                document.getElementById('weather_sealed').addEventListener('change', handleFilterChange);
                document.getElementById('is_macro').addEventListener('change', handleFilterChange);
                elements.focalChoice.addEventListener('input', handleFilterChange);
                document.getElementById('subject_distance').addEventListener('input', handleFilterChange);
                elements.goalPreset.addEventListener('change', handlePresetChange);
                elements.customWeights.addEventListener('input', handleWeightChange);
                if (elements.downloadCsv) elements.downloadCsv.addEventListener('click', downloadCSV);
                elements.sidebarOpen.addEventListener('click', () => elements.sidebar.classList.remove('hidden-mobile'));
                elements.sidebarClose.addEventListener('click', () => elements.sidebar.classList.add('hidden-mobile'));
            }
            
            function updateUIMode() {
                const isPro = elements.uiModeToggle.checked;
                state.filters.isProMode = isPro;
                elements.proSections.style.display = isPro ? 'block' : 'none';
                elements.proLabel.classList.toggle('text-white', isPro);
                elements.proLabel.classList.toggle('text-gray-400', !isPro);
                elements.newbieLabel.classList.toggle('text-white', !isPro);
                elements.newbieLabel.classList.toggle('text-gray-400', isPro);
            }

            function handleFilterChange(e) {
                const { id, value, type, checked } = e.target;
                if (id === 'camera_body') {
                    state.filters.camera = state.cameras.find(c => c.name === value);
                } else if (type === 'checkbox') {
                    state.filters[id.replace('-','_')] = checked;
                } else if (type === 'number') {
                    state.filters[id.replace('-','_')] = parseFloat(value);
                } else {
                    state.filters[id.replace('-','_')] = value;
                }
                update();
            }

            function handlePresetChange(e) {
                const presetName = e.target.value;
                if (recommender.PRESETS[presetName]) {
                    state.filters.goal_weights = { ...recommender.PRESETS[presetName] };
                    createWeightSliders();
                    update();
                }
            }

            function handleWeightChange(e) {
                 if (e.target.type === 'range') {
                    const { key } = e.target.dataset;
                    state.filters.goal_weights[key] = parseFloat(e.target.value);
                    if (!elements.goalPreset.querySelector('option[value="Custom"]')) {
                       const customOption = document.createElement('option');
                       customOption.value = "Custom"; customOption.textContent = "Custom";
                       elements.goalPreset.appendChild(customOption);
                    }
                    elements.goalPreset.value = "Custom";
                    update();
                }
            }
            
            function update() {
                // Main update logic...
                const compatibleLenses = state.lenses.filter(lens => lens.mount === state.filters.camera.mount);
                const compatibleBrands = ['Any', ...new Set(compatibleLenses.map(l => l.brand))].sort();
                populateSelect(elements.brand, compatibleBrands, state.filters.brand);
                if (!compatibleBrands.includes(state.filters.brand)) {
                    state.filters.brand = 'Any';
                    elements.brand.value = 'Any';
                }

                const filteredLenses = compatibleLenses.filter(lens => {
                    if (state.filters.brand !== 'Any' && lens.brand !== state.filters.brand) return false;
                    const lensType = recommender.isZoom(lens) ? 'Zoom' : 'Prime';
                    if (state.filters.lens_type !== 'Any' && lensType !== state.filters.lens_type) return false;
                    if (document.getElementById('weather_sealed').checked && !lens.weather_sealed) return false;
                    if (document.getElementById('is_macro').checked && !lens.is_macro) return false;
                    return true;
                });

                state.results = filteredLenses.map(lens => {
                    const fc = state.filters.isProMode ? Math.max(lens.focal_min_mm, Math.min(state.filters.focal_choice, lens.focal_max_mm)) : (lens.focal_min_mm + lens.focal_max_mm) / 2;
                    const scores = recommender.scoreLens(lens, state.filters.camera, state.filters.goal_weights, fc);
                    const { h } = optics.fovDeg(state.filters.camera.sensor, fc);
                    const { total } = optics.depthOfFieldMm(fc, recommender.maxApertureAt(lens, fc), state.filters.camera.sensor.coc_mm, state.filters.subject_distance * 1000);
                    
                    return { 
                        ...lens, 
                        ...scores,
                        focal_used_mm: fc,
                        max_aperture_at_focal: recommender.maxApertureAt(lens, fc),
                        eq_focal_ff_mm: optics.equivFocalFf(fc, state.filters.camera.sensor),
                        fov_h_deg: h,
                        dof_total_m: total / 1000,
                        stabilization: (lens.ois || state.filters.camera.ibis) ? '‚úÖ' : '‚ùå',
                        score_total: scores.total
                     };
                }).sort((a, b) => b.total - a.total);

                updateSystemCard();
                renderTable();
                renderCharts();
            }
            
            function updateSystemCard(lens = null) {
                state.selectedLens = lens;
                const camera = state.filters.camera;
                elements.systemCameraName.textContent = camera.name;
                elements.cameraIcon.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="96" height="96" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"></path><circle cx="12" cy="13" r="3"></circle></svg>`;
                if (lens) {
                    elements.systemLensName.textContent = lens.name;
                    elements.systemWeight.textContent = `${camera.weight_g + lens.weight_g} g`;
                    elements.systemCost.textContent = `CHF ${camera.price_chf + lens.price_chf}`;
                } else {
                    elements.systemLensName.textContent = 'No lens selected';
                    elements.systemWeight.textContent = `${camera.weight_g} g`;
                    elements.systemCost.textContent = `CHF ${camera.price_chf}`;
                }
            }

            function renderTable() {
                if (state.results.length === 0) {
                    elements.resultsContainer.classList.add('hidden');
                    elements.noResults.classList.remove('hidden');
                    return;
                }
                elements.resultsContainer.classList.remove('hidden');
                elements.noResults.classList.add('hidden');
                
                const headers = ['Name', 'Focal', 'Aperture', 'Eq. Focal', 'Horiz. FoV', 'DoF Total', 'Weight', 'Price', 'Stab.', 'Sealed', 'Macro', 'Score'];
                elements.resultsHeader.innerHTML = headers.map(h => `<th class="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">${h}</th>`).join('');
                
                elements.resultsBody.innerHTML = state.results.map((res, index) => `
                    <tr class="hover:bg-gray-700/50 cursor-pointer" data-lens-index="${index}">
                        <td class="px-4 py-3 whitespace-nowrap text-sm font-medium text-white"><a href="${res.source_url}" target="_blank" rel="noopener noreferrer" class="hover:text-blue-400 transition-colors" onclick="event.stopPropagation()">${res.name}</a></td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-300">${res.focal_used_mm.toFixed(0)}mm</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-300">f/${res.max_aperture_at_focal.toFixed(1)}</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-300">${res.eq_focal_ff_mm.toFixed(1)}mm</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-300">${res.fov_h_deg.toFixed(1)}¬∞</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-300">${res.dof_total_m === Infinity ? '‚àû' : res.dof_total_m.toFixed(2)}m</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-300">${res.weight_g}g</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-300">CHF ${res.price_chf}</td>
                        <td class="px-4 py-3 whitespace-nowrap text-center text-sm text-gray-300">${res.stabilization}</td>
                        <td class="px-4 py-3 whitespace-nowrap text-center text-sm text-gray-300">${res.weather_sealed ? '‚úÖ' : '‚ùå'}</td>
                        <td class="px-4 py-3 whitespace-nowrap text-center text-sm text-gray-300">${res.is_macro ? '‚úÖ' : '‚ùå'}</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm font-bold text-blue-400">${res.score_total.toFixed(0)}</td>
                    </tr>
                `).join('');

                elements.resultsBody.querySelectorAll('tr').forEach(row => {
                    row.addEventListener('click', (e) => {
                        if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'A') {
                            const lensIndex = parseInt(row.dataset.lensIndex);
                            const lens = state.results[lensIndex];
                            updateSystemCard(lens);
                        }
                    });
                });
            }
            
            function renderCharts() {
                 const plotlyLayout = {
                    paper_bgcolor: 'transparent',
                    plot_bgcolor: 'transparent',
                    font: { color: '#d1d5db' },
                    xaxis: { gridcolor: 'rgba(255,255,255,0.1)', linecolor: 'rgba(255,255,255,0.2)', zerolinecolor: 'rgba(255,255,255,0.2)' },
                    yaxis: { gridcolor: 'rgba(255,255,255,0.1)', linecolor: 'rgba(255,255,255,0.2)', zerolinecolor: 'rgba(255,255,255,0.2)' },
                    legend: { bgcolor: 'rgba(0,0,0,0.5)', bordercolor: '#4b5563' },
                    margin: { l: 50, r: 20, b: 40, t: 20, pad: 4 }
                };

                if (state.results.length > 0) {
                    const points = state.results.map(r => {
                        const xRaw = optics.equivFocalFf(r.focal_used_mm, state.filters.camera.sensor);
                        const yRaw = optics.fovDeg(state.filters.camera.sensor, r.focal_used_mm).h;
                        const x = Math.max(0.001, xRaw);
                        const y = Math.min(179.999, Math.max(0.001, yRaw));
                        const size = Math.max(8, 25 - recommender.maxApertureAt(r, r.focal_used_mm) * 3);
                        const color = r.score_total;
                        const text = `${r.name}<br>Score: ${r.score_total.toFixed(0)}`;
                        return { x, y, size, color, text };
                    }).filter(p => Number.isFinite(p.x) && Number.isFinite(p.y) && Number.isFinite(p.size) && Number.isFinite(p.color));

                    if (points.length > 0) {
                        const xs = points.map(p => p.x);
                        const ys = points.map(p => p.y);
                        const minMax = arr => ({
                            min: arr.reduce((m, v) => Math.min(m, v), Number.POSITIVE_INFINITY),
                            max: arr.reduce((m, v) => Math.max(m, v), Number.NEGATIVE_INFINITY)
                        });
                        const xr = minMax(xs);
                        const yr = minMax(ys);
                        const padRange = (r) => {
                            if (!Number.isFinite(r.min) || !Number.isFinite(r.max)) return null;
                            if (r.min === r.max) {
                                const pad = Math.max(1, Math.abs(r.max) * 0.1);
                                return [r.min - pad, r.max + pad];
                            }
                            const span = r.max - r.min;
                            const pad = Math.max(1e-6, span * 0.05);
                            return [r.min - pad, r.max + pad];
                        };
                        const xRange = padRange(xr);
                        const yRange = padRange(yr);

                        const fovTrace = {
                            x: xs,
                            y: ys,
                            text: points.map(p => p.text),
                            hoverinfo: 'text',
                            mode: 'markers',
                            type: 'scatter',
                            marker: {
                                size: points.map(p => p.size),
                                color: points.map(p => p.color),
                                colorscale: 'Viridis',
                                showscale: true,
                                colorbar: { title: 'Score', thickness: 10 }
                            }
                        };
                        const xaxis = { ...plotlyLayout.xaxis, title: 'Equivalent Focal (mm, FF)', type: 'linear' };
                        const yaxis = { ...plotlyLayout.yaxis, title: 'Horizontal FOV (deg)', type: 'linear' };
                        if (xRange) xaxis.range = xRange;
                        if (yRange) yaxis.range = yRange;
                        const fovLayout = {
                            ...plotlyLayout,
                            height: 380,
                            autosize: true,
                            xaxis,
                            yaxis
                        };
                        const el = document.getElementById('chart-fov');
                        if (el) el.style.minHeight = '320px';
                        let tries = 0;
                        const draw = () => {
                            if (!el || el.clientWidth === 0 || el.clientHeight === 0) {
                                if (tries++ < 20) return setTimeout(draw, 50);
                                console.warn('FOV chart skipped due to zero-size container');
                                return Plotly.purge('chart-fov');
                            }
                            try {
                                Plotly.newPlot('chart-fov', [fovTrace], fovLayout, {responsive: true});
                            } catch (inner) {
                                console.warn('FOV chart skipped due to plotting error:', inner);
                                Plotly.purge('chart-fov');
                            }
                        };
                        draw();
                    } else {
                        Plotly.purge('chart-fov');
                    }
                } else {
                    Plotly.purge('chart-fov');
                }

                if (state.results.length > 0) {
                    const sortedResults = [...state.results]
                        .filter(r => Number.isFinite(r.score_total) && typeof r.name === 'string')
                        .sort((a, b) => a.score_total - b.score_total)
                        .slice(-15);

                    if (sortedResults.length > 0) {
                        const scoreTrace = {
                            x: sortedResults.map(r => r.score_total),
                            y: sortedResults.map(r => r.name),
                            type: 'bar',
                            orientation: 'h',
                            marker: {
                                color: sortedResults.map(r => r.total),
                                colorscale: 'Blues',
                            }
                        };
                        const scoreLayout = { ...plotlyLayout, yaxis: { ...plotlyLayout.yaxis, automargin: true }, xaxis: { ...plotlyLayout.xaxis, title: 'Weighted Score'}};
                        try {
                            Plotly.newPlot('chart-score', [scoreTrace], scoreLayout, {responsive: true});
                        } catch (e) {
                            console.warn('Score chart skipped due to plotting error:', e);
                            Plotly.purge('chart-score');
                        }
                    } else {
                        Plotly.purge('chart-score');
                    }
                } else {
                    Plotly.purge('chart-score');
                }
            }

            function downloadCSV() {
                if (state.results.length === 0) return;
                const headers = ['Name','Focal(mm)','Aperture(f/)','Eq.Focal(mm)','FoV H(deg)','DoF Total(m)','Weight(g)','Price(CHF)','Stabilized','Sealed','Macro','Score'];
                const rows = state.results.map(r => [
                    r.name,
                    r.focal_used_mm.toFixed(0),
                    r.max_aperture_at_focal.toFixed(1),
                    r.eq_focal_ff_mm.toFixed(1),
                    r.fov_h_deg.toFixed(1),
                    (r.dof_total_m === Infinity ? '‚àû' : r.dof_total_m.toFixed(2)),
                    r.weight_g,
                    r.price_chf,
                    r.stabilization,
                    r.weather_sealed ? '‚úÖ' : '‚ùå',
                    r.is_macro ? '‚úÖ' : '‚ùå',
                    r.score_total.toFixed(0)
                ]);
                const csv = [headers, ...rows]
                  .map(line => line.map(v => (typeof v === 'string' && v.includes(',') ? '"'+v+'"' : v)).join(','))
                  .join('\n');
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = 'lens_results.csv'; a.style.display = 'none';
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            }

            // Load external data then initialize
            loadDataThenInit();
        });
    </script>

</body>
</html>
